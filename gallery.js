// gallery.js - Portfolio Gallery Logic
// Fetches files.json (generated by make_files_index.py) and renders cards.
// Falls back gracefully if files.json missing.

(function(){
  const grid = document.getElementById('gallery-grid');
  const statusBar = document.getElementById('status-bar');
  const searchBox = document.getElementById('search-box');
  const countEl = document.getElementById('count');
  const scanToggle = document.getElementById('scan-toggle');
  const scanProgress = document.getElementById('scan-progress');
  const scanBar = document.getElementById('scan-progress-bar');
  let metaList = []; // full list
  let filtered = [];

  // Fallback enumeration config (for setups WITHOUT files.json build step)
  // Assumes files named data/student1.json, data/student2.json ... sequentially.
  // You can adjust pattern() or limits below to match your naming scheme.
  const ENUM_FALLBACK = {
    enabled: true,
    start: 1,
    max: 200,              // numeric pattern scan ceiling
    consecutiveFailStop: 8, // numeric pattern stop on misses
    pattern: i => `data/student${i}.json`,
    // Arbitrary filename heuristic list (common patterns + short names)
    arbitraryCandidates: [
      // common base names
      'portfolio','student','profile','record','medfolio','cv','resume','academic','clinical','research','extracurricular','reflection','main','data','index','overview','summary',
      // sample ids
      'student_a','student_b','student_c','student_x','student_y','student_z',
      // year variants
      '2024','2025','2026','year1','year2','year3','year4','final','draft','latest','backup'
    ],
    // suffix permutations appended to base names
    arbitrarySuffixes: ['', '-portfolio','-data','-profile','-record','-v1','-v2','-final'],
    extensions: ['.json'],
    // hard cap on arbitrary tries
    arbitraryMax: 180
  };
  let enumAborted = false;
  let arbitraryMode = false;

  function escapeHtml(str){
    if(str == null) return '';
    return String(str).replace(/[&<>"]/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;'}[c]||c));
  }

  function setStatus(msg){ if(statusBar) statusBar.textContent = msg; }

  function render(){
    grid.classList.add('list-mode');
    grid.innerHTML = '';
    
    if(!filtered.length){
      const div = document.createElement('div');
      div.className = 'gal-empty';
      div.innerHTML = '<strong>No portfolios found</strong><span>Place JSON files in data/ then regenerate files.json.</span>';
      grid.appendChild(div);
      if(countEl) countEl.textContent = '';
      return;
    }
    
    // Performance optimization for large datasets
    const BATCH_SIZE = 50;
    const totalItems = filtered.length;
    
    if(totalItems > 200){
      setStatus(`Rendering ${totalItems} portfolios...`);
    }
    
    function renderBatch(startIndex) {
      const frag = document.createDocumentFragment();
      const endIndex = Math.min(startIndex + BATCH_SIZE, totalItems);
      
      for(let i = startIndex; i < endIndex; i++) {
        const m = filtered[i];
        const a = document.createElement('a');
        // Add timestamp to force fresh loading and prevent cache
        const timestamp = Date.now();
        a.href = `portfolio.html?file=${encodeURIComponent(m.file)}&t=${timestamp}`;
        a.className = 'gal-row';
        a.setAttribute('role','listitem');
        a.setAttribute('data-name', (m.name||'').toLowerCase());
        a.tabIndex = 0;

        const left = document.createElement('div');
        left.className = 'row-left';
        const fileEl = document.createElement('div');
        fileEl.className = 'row-file';
        fileEl.textContent = m.file.replace(/^data\//,'');  // Show filename only
        const nameEl = document.createElement('div');
        nameEl.className = 'row-name';
        nameEl.textContent = m.name || 'untitled';  // Show filename as name
        left.appendChild(fileEl);
        left.appendChild(nameEl);
        a.appendChild(left);

        // Add click handler to clear cache before navigation
        a.addEventListener('click', function(e) {
          // Clear all portfolio-related data before navigation
          try {
            localStorage.clear();
            sessionStorage.clear();
            console.log('[gallery] Cleared all cache before loading:', m.file);
          } catch(err) {}
        });

        a.addEventListener('keydown', (e)=>{
          if(e.key === 'Enter' || e.key === ' '){ e.preventDefault(); a.click(); }
        });
        frag.appendChild(a);
      }
      
      grid.appendChild(frag);
      
      // Continue with next batch if needed
      if(endIndex < totalItems) {
        setTimeout(() => renderBatch(endIndex), 0);
      } else {
        // Rendering complete
        if(totalItems > 200) setStatus('');
        if(countEl) countEl.textContent = totalItems + ' portfolios';
      }
    }
    
    // Start rendering
    renderBatch(0);
    
    // Immediate count update for small datasets
    if(totalItems <= 200 && countEl) {
      countEl.textContent = totalItems + ' portfolios';
    }
  }

  let searchTimeout;
  function applyFilter(){
    // In admin mode, gallery search should not interfere with admin list filtering
    try {
      if (window.__DISABLE_GALLERY_SEARCH || document.body.classList.contains('admin-mode')) {
        return;
      }
    } catch(_) {}
    // Clear previous timeout to debounce rapid typing
    clearTimeout(searchTimeout);
    
    searchTimeout = setTimeout(() => {
      const q = (searchBox.value || '').toLowerCase().trim();
      
      if(!q){ 
        filtered = metaList.slice(); 
        render(); 
        return; 
      }
      
      // Search across combined terms (name + filename)
      filtered = metaList.filter(m => {
        const terms = m._terms || (m._name || '') + ' ' + (m.file || '');
        return terms.includes(q);
      });
      
      render();
    }, metaList.length > 100 ? 300 : 150); // Longer debounce for large datasets
  }

  async function loadIndex(){
    // Skip index loading when admin mode is active
    try { if (document.body.classList.contains('admin-mode')) return; } catch(_) {}
    setStatus('Loading portfolio index...');

    // Clear any previous portfolio data from memory/cache
    if(typeof localStorage !== 'undefined') {
      try {
        localStorage.removeItem('personalInfo');
        localStorage.removeItem('profilePhoto');
        localStorage.removeItem('portfolioData');
        console.log('[gallery] Cleared localStorage cache');
      } catch(e) {}
    }

    let filesLoaded = false;

    // 1) Try files.json first (local/static manifest)
    try{
      const t0_files = performance.now();
      const cacheBuster = Date.now();
      const resp = await fetch(`files.json?t=${cacheBuster}`, {
        cache:'no-store',
        headers: {
          'Cache-Control': 'no-cache, no-store, must-revalidate',
          'Pragma': 'no-cache',
          'Expires': '0'
        }
      });
      if(resp.ok){
        const t1_files = performance.now();
        console.info('[gallery] files.json fetched', { status: resp.status, durationMs: Math.round(t1_files - t0_files) });
        let arr;
        try { arr = await resp.json(); } catch(parseErr){ console.warn('[gallery] files.json parse error', parseErr); throw parseErr; }
        if(Array.isArray(arr)){
          metaList = arr.map(m => ({ file: m.file, name: m.name || m.file || 'untitled' }));
          metaList.forEach(m => { const name = (m.name||'').toLowerCase(); const file = (m.file||'').toLowerCase(); m._name = name; m._terms = `${name} ${file}`.trim(); });
          filtered = metaList.slice();
          if(metaList.length > 500) setStatus(`Loaded ${metaList.length} portfolios. Rendering...`); else setStatus('');
          render();
          filesLoaded = true;
          if (ENUM_FALLBACK.enabled) { ENUM_FALLBACK.enabled = false; console.log('[gallery] files.json loaded successfully â€“ fallback enumeration disabled.'); }
        }
      }
    } catch(e){
      console.warn('files.json load failed:', e);
    }

    // 2) If files.json not present, try backend /api/list (authenticated)
    if(!filesLoaded){
      try {
        setStatus('No index file found. Fetching from backend...');
        const t0_backend = performance.now();

        // Ensure RMU_AUTH exists and get a token (authenticateUser returns {token,email,..})
        let token = '';
        if(window.RMU_AUTH && typeof window.RMU_AUTH.authenticateUser === 'function'){
          try {
            const authResult = await window.RMU_AUTH.authenticateUser();
            token = authResult && authResult.token ? authResult.token : '';
          } catch(authErr){
            // Authentication required - prompt user via UI (welcome modal handles sign-in flow)
            setStatus('Sign in required to view Drive portfolios. Click "Sign in with Google".');
            console.warn('Authentication required for backend manifest:', authErr && authErr.message ? authErr.message : authErr);
            // Don't proceed to backend call without token
            token = '';
          }
        }

        if(token){
          const backendUrl = (window.RMU_CONFIG && window.RMU_CONFIG.BACKEND_BASE) ? window.RMU_CONFIG.BACKEND_BASE.replace(/\/$/, '') : '';
          if(backendUrl){
            const controller = new AbortController();
            const timeout = setTimeout(() => controller.abort(), (window.RMU_CONFIG && window.RMU_CONFIG.API_TIMEOUT) || 30000);
            const resp = await fetch(`${backendUrl}/api/list`, {
              method: 'GET',
              headers: { 'Authorization': `Bearer ${token}`, 'Content-Type': 'application/json' },
              credentials: 'omit',
              cache: 'no-store',
              signal: controller.signal
            });
            clearTimeout(timeout);
            const t1_backend = performance.now();
            console.info('[gallery] /api/list response', { status: resp.status, durationMs: Math.round(t1_backend - t0_backend) });
            if(resp.ok){
              // backend may return { manifest: [...] } or an array directly; handle both
              let dataText = null;
              let data = null;
              try {
                dataText = await resp.text();
                try { data = JSON.parse(dataText); } catch(e){ /* leave as null */ }
              } catch(e){ console.warn('[gallery] Failed to read backend body', e); }
              // If backend returned an array directly, normalize
              if(Array.isArray(data)) data = { manifest: data };
              if(data && Array.isArray(data.manifest)){
                metaList = data.manifest.map(m => ({ file: m.file, name: m.name || m.file || 'untitled' }));
                metaList.forEach(m => { const name = (m.name||'').toLowerCase(); const file = (m.file||'').toLowerCase(); m._name = name; m._terms = `${name} ${file}`.trim(); });
                filtered = metaList.slice();
                setStatus(`Loaded ${metaList.length} portfolios from Drive.`);
                render();
                filesLoaded = true;
                console.debug('[gallery] backend manifest sample', metaList.slice(0,5));
              } else {
                console.warn('Backend returned no manifest or unexpected shape', { parsed: data, raw: (dataText || '').slice(0,200) });
                setStatus('No portfolios found in Drive.');
              }
            } else {
              // Backend returned non-OK (likely 401/403) - show sign-in message
              if(resp.status === 401 || resp.status === 403){
                setStatus('Sign in required to access Drive portfolios.');
              } else {
                setStatus('Failed to fetch portfolios from backend.');
              }
              let bodySnippet = '';
              try { bodySnippet = (await resp.text()).slice(0,300); } catch(_){}
              console.warn('Backend /api/list responded', resp.status, resp.statusText, bodySnippet);
            }
          } else {
            console.warn('Backend URL not configured in RMU_CONFIG.BACKEND_BASE');
            setStatus('Backend not configured.');
          }
        }
      } catch(e){
        console.warn('Backend fetch error:', e);
        setStatus('Error fetching portfolios from backend.');
      }
    }

    // 3) If still not loaded, fallback to local /data enumeration
    if(!filesLoaded){
      if(ENUM_FALLBACK.enabled){
        scheduleEnumerationFallback();
      } else {
        setStatus('No index file found. Run the indexer script to generate files.json.');
      }
    }
  }

  function scheduleEnumerationFallback(){
    if(scanToggle && !scanToggle.checked){
      setStatus('Index missing. (Auto scan disabled)');
      return;
    }
    setStatus('Index missing. Scanning data/ ...');
    // Start both numeric and arbitrary in sequence; numeric first for speed if pattern fits.
    enumeratePattern().then(()=>{
      if(!metaList.length){
        arbitraryMode = true;
        enumerateArbitrary();
      } else {
        // Also try arbitrary to pick up differently named files
        arbitraryMode = true;
        enumerateArbitrary();
      }
    });
  }

  async function enumeratePattern(){
    const cfg = ENUM_FALLBACK;
    let consecutiveFails = 0;
    showProgress(true);
    for(let i = cfg.start; i <= cfg.max; i++){
      if(enumAborted) return;
      const file = cfg.pattern(i);
      try {
        const r = await fetch(file, {cache:'no-store'});
        if(!r.ok){
          consecutiveFails++;
          if(consecutiveFails >= cfg.consecutiveFailStop){
            break;
          }
          continue;
        }
        consecutiveFails = 0; // reset on success
        const obj = await r.json();
        const entry = normalizeMetaFromRaw(file, obj);
        metaList.push(entry);
        filtered = metaList.slice();
        setStatus(`Discovered ${metaList.length} file(s) ... (numeric)`);
        updateProgress(i / cfg.max);
        render();
      } catch(err){
        consecutiveFails++;
        if(consecutiveFails >= cfg.consecutiveFailStop){
          break;
        }
      }
    }
    if(!metaList.length){
      setStatus('No numeric pattern matches, trying filename heuristics...');
    }
    showProgress(false);
  }

  async function enumerateArbitrary(){
    const cfg = ENUM_FALLBACK;
    const tries = [];
    for(const base of cfg.arbitraryCandidates){
      for(const suf of cfg.arbitrarySuffixes){
        for(const ext of cfg.extensions){
          tries.push(`data/${base}${suf}${ext}`);
          if(tries.length >= cfg.arbitraryMax) break;
        }
        if(tries.length >= cfg.arbitraryMax) break;
      }
      if(tries.length >= cfg.arbitraryMax) break;
    }
    let attempted = 0;
    showProgress(true);
    for(const file of tries){
      if(enumAborted) return;
      attempted++;
      try {
        const r = await fetch(file, {cache:'no-store'});
        if(!r.ok) { continue; }
        const obj = await r.json();
        if(metaList.some(m => m.file === file)) continue; // avoid dup
  const entry = normalizeMetaFromRaw(file, obj);
        metaList.push(entry);
        filtered = metaList.slice();
        setStatus(`Discovered ${metaList.length} file(s) ... (arbitrary)`);
        updateProgress(attempted / tries.length);
        render();
      } catch(e){ /* ignore */ }
    }
    showProgress(false);
    if(!metaList.length){
      setStatus('No portfolios found (heuristic scan empty).');
    } else {
      setStatus('');
    }
  }

  function showProgress(on){
    if(!scanProgress) return;
    scanProgress.style.display = on ? 'block' : 'none';
    if(on && scanBar) scanBar.style.width = '4%';
  }
  function updateProgress(f){ if(scanBar) scanBar.style.width = Math.min(100, Math.max(4, f*100)).toFixed(1)+'%'; }

  function normalizeMetaFromRaw(file, raw){
    const name = raw.name || raw.title || 'Untitled';
    const m = { file, name };
    const n = (name||'').toLowerCase();
    const f = (file||'').toLowerCase();
    m._name = n;
    m._terms = `${n} ${f}`.trim();
    return m;
  }

  // firstImage removed (no longer needed)

  if(searchBox){ searchBox.addEventListener('input', applyFilter); }
  if(scanToggle){
    scanToggle.addEventListener('change', ()=>{
      if(!scanToggle.checked){
        enumAborted = true;
        showProgress(false);
        setStatus('Auto scan disabled.');
      } else {
        enumAborted = false;
        if(!metaList.length){ scheduleEnumerationFallback(); }
      }
    });
  }
  loadIndex();
  // Note: Chrome "Intervention" message about lazy images is informational only; we intentionally use native lazy-loading.
})();
