// gallery.js - Portfolio Gallery Logic
// Fetches files.json (generated by make_files_index.py) and renders cards.
// Falls back gracefully if files.json missing.

(function(){
  const grid = document.getElementById('gallery-grid');
  const statusBar = document.getElementById('status-bar');
  const searchBox = document.getElementById('search-box');
  const countEl = document.getElementById('count');
  const scanToggle = document.getElementById('scan-toggle');
  const scanProgress = document.getElementById('scan-progress');
  const scanBar = document.getElementById('scan-progress-bar');
  let metaList = []; // full list
  let filtered = [];

  // Fallback enumeration config (for setups WITHOUT files.json build step)
  // Assumes files named data/student1.json, data/student2.json ... sequentially.
  // You can adjust pattern() or limits below to match your naming scheme.
  const ENUM_FALLBACK = {
    enabled: true,
    start: 1,
    max: 200,              // numeric pattern scan ceiling
    consecutiveFailStop: 8, // numeric pattern stop on misses
    pattern: i => `data/student${i}.json`,
    // Arbitrary filename heuristic list (common patterns + short names)
    arbitraryCandidates: [
      // common base names
      'portfolio','student','profile','record','medfolio','cv','resume','academic','clinical','research','extracurricular','reflection','main','data','index','overview','summary',
      // sample ids
      'student_a','student_b','student_c','student_x','student_y','student_z',
      // year variants
      '2024','2025','2026','year1','year2','year3','year4','final','draft','latest','backup'
    ],
    // suffix permutations appended to base names
    arbitrarySuffixes: ['', '-portfolio','-data','-profile','-record','-v1','-v2','-final'],
    extensions: ['.json'],
    // hard cap on arbitrary tries
    arbitraryMax: 180
  };
  let enumAborted = false;
  let arbitraryMode = false;

  function escapeHtml(str){
    if(str == null) return '';
    return String(str).replace(/[&<>"]/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;'}[c]||c));
  }

  function setStatus(msg){ if(statusBar) statusBar.textContent = msg; }

  function render(){
    grid.classList.add('list-mode');
    grid.innerHTML = '';
    
    if(!filtered.length){
      const div = document.createElement('div');
      div.className = 'gal-empty';
      div.innerHTML = '<strong>No portfolios found</strong><span>Place JSON files in data/ then regenerate files.json.</span>';
      grid.appendChild(div);
      if(countEl) countEl.textContent = '';
      return;
    }
    
    // Performance optimization for large datasets
    const BATCH_SIZE = 50;
    const totalItems = filtered.length;
    
    if(totalItems > 200){
      setStatus(`Rendering ${totalItems} portfolios...`);
    }
    
    function renderBatch(startIndex) {
      const frag = document.createDocumentFragment();
      const endIndex = Math.min(startIndex + BATCH_SIZE, totalItems);
      
      for(let i = startIndex; i < endIndex; i++) {
        const m = filtered[i];
        const a = document.createElement('a');
        // Add timestamp to force fresh loading and prevent cache
        const timestamp = Date.now();
        a.href = `portfolio.html?file=${encodeURIComponent(m.file)}&t=${timestamp}`;
        a.className = 'gal-row';
        a.setAttribute('role','listitem');
        a.setAttribute('data-name', (m.name||'').toLowerCase());
        a.tabIndex = 0;

        const left = document.createElement('div');
        left.className = 'row-left';
        const fileEl = document.createElement('div');
        fileEl.className = 'row-file';
        fileEl.textContent = m.file.replace(/^data\//,'');  // Show filename only
        const nameEl = document.createElement('div');
        nameEl.className = 'row-name';
        nameEl.textContent = m.name || 'untitled';  // Show filename as name
        left.appendChild(fileEl);
        left.appendChild(nameEl);
        a.appendChild(left);

        // Add click handler to clear cache before navigation
        a.addEventListener('click', function(e) {
          // Clear all portfolio-related data before navigation
          try {
            localStorage.clear();
            sessionStorage.clear();
            console.log('[gallery] Cleared all cache before loading:', m.file);
          } catch(err) {}
        });

        a.addEventListener('keydown', (e)=>{
          if(e.key === 'Enter' || e.key === ' '){ e.preventDefault(); a.click(); }
        });
        frag.appendChild(a);
      }
      
      grid.appendChild(frag);
      
      // Continue with next batch if needed
      if(endIndex < totalItems) {
        setTimeout(() => renderBatch(endIndex), 0);
      } else {
        // Rendering complete
        if(totalItems > 200) setStatus('');
        if(countEl) countEl.textContent = totalItems + ' portfolios';
      }
    }
    
    // Start rendering
    renderBatch(0);
    
    // Immediate count update for small datasets
    if(totalItems <= 200 && countEl) {
      countEl.textContent = totalItems + ' portfolios';
    }
  }

  let searchTimeout;
  function applyFilter(){
    // In admin mode, gallery search should not interfere with admin list filtering
    try {
      if (window.__DISABLE_GALLERY_SEARCH || document.body.classList.contains('admin-mode')) {
        return;
      }
    } catch(_) {}
    // Clear previous timeout to debounce rapid typing
    clearTimeout(searchTimeout);
    
    searchTimeout = setTimeout(() => {
      const q = (searchBox.value || '').toLowerCase().trim();
      
      if(!q){ 
        filtered = metaList.slice(); 
        render(); 
        return; 
      }
      
      // Search across combined terms (name + filename)
      filtered = metaList.filter(m => {
        const terms = m._terms || (m._name || '') + ' ' + (m.file || '');
        return terms.includes(q);
      });
      
      render();
    }, metaList.length > 100 ? 300 : 150); // Longer debounce for large datasets
  }

  async function loadIndex(){
    // Skip index loading when admin mode is active
    try { if (document.body.classList.contains('admin-mode')) return; } catch(_) {}
    setStatus('Loading portfolio index...');
    
    // Clear any previous portfolio data from memory/cache
    if(typeof localStorage !== 'undefined') {
      try {
        localStorage.removeItem('personalInfo');
        localStorage.removeItem('profilePhoto');
        localStorage.removeItem('portfolioData');
        console.log('[gallery] Cleared localStorage cache');
      } catch(e) {}
    }
    
    try{
      // Add timestamp cache-busting to ensure fresh index data
      const cacheBuster = Date.now();
      const resp = await fetch(`files.json?t=${cacheBuster}`, {
        cache:'no-store',
        headers: {
          'Cache-Control': 'no-cache, no-store, must-revalidate',
          'Pragma': 'no-cache',
          'Expires': '0'
        }
      });
      if(!resp.ok) throw new Error('HTTP '+resp.status);
      
      const arr = await resp.json();
      if(!Array.isArray(arr)) throw new Error('files.json malformed');
      
      // Process the loaded data
      metaList = arr.map(m => ({
        file: m.file,
        name: m.name || m.file || 'untitled'
      }));
      
      // Prepare combined search terms: name + filename
      metaList.forEach(m => {
        const name = (m.name||'').toLowerCase();
        const file = (m.file||'').toLowerCase();
        m._name = name;
        m._terms = `${name} ${file}`.trim();
      });
      filtered = metaList.slice();
      
      // Performance feedback for large datasets  
      if(metaList.length > 500){
        setStatus(`Loaded ${metaList.length} portfolios. Rendering...`);
      } else {
        setStatus('');
      }
      
      render();
      // Successful load: permanently disable enumeration fallback for this session
      if (ENUM_FALLBACK.enabled) {
        ENUM_FALLBACK.enabled = false;
        console.log('[gallery] files.json loaded successfully â€“ fallback enumeration disabled.');
      }
      
    } catch(e){
      console.warn('files.json load failed:', e);
      metaList = []; filtered = [];
      render();
      
      if(ENUM_FALLBACK.enabled){
        scheduleEnumerationFallback();
      } else {
        setStatus('No index file found. Run the indexer script to generate files.json.');
      }
    }
  }

  function scheduleEnumerationFallback(){
    if(scanToggle && !scanToggle.checked){
      setStatus('Index missing. (Auto scan disabled)');
      return;
    }
    setStatus('Index missing. Scanning data/ ...');
    // Start both numeric and arbitrary in sequence; numeric first for speed if pattern fits.
    enumeratePattern().then(()=>{
      if(!metaList.length){
        arbitraryMode = true;
        enumerateArbitrary();
      } else {
        // Also try arbitrary to pick up differently named files
        arbitraryMode = true;
        enumerateArbitrary();
      }
    });
  }

  async function enumeratePattern(){
    const cfg = ENUM_FALLBACK;
    let consecutiveFails = 0;
    showProgress(true);
    for(let i = cfg.start; i <= cfg.max; i++){
      if(enumAborted) return;
      const file = cfg.pattern(i);
      try {
        const r = await fetch(file, {cache:'no-store'});
        if(!r.ok){
          consecutiveFails++;
          if(consecutiveFails >= cfg.consecutiveFailStop){
            break;
          }
          continue;
        }
        consecutiveFails = 0; // reset on success
        const obj = await r.json();
        const entry = normalizeMetaFromRaw(file, obj);
        metaList.push(entry);
        filtered = metaList.slice();
        setStatus(`Discovered ${metaList.length} file(s) ... (numeric)`);
        updateProgress(i / cfg.max);
        render();
      } catch(err){
        consecutiveFails++;
        if(consecutiveFails >= cfg.consecutiveFailStop){
          break;
        }
      }
    }
    if(!metaList.length){
      setStatus('No numeric pattern matches, trying filename heuristics...');
    }
    showProgress(false);
  }

  async function enumerateArbitrary(){
    const cfg = ENUM_FALLBACK;
    const tries = [];
    for(const base of cfg.arbitraryCandidates){
      for(const suf of cfg.arbitrarySuffixes){
        for(const ext of cfg.extensions){
          tries.push(`data/${base}${suf}${ext}`);
          if(tries.length >= cfg.arbitraryMax) break;
        }
        if(tries.length >= cfg.arbitraryMax) break;
      }
      if(tries.length >= cfg.arbitraryMax) break;
    }
    let attempted = 0;
    showProgress(true);
    for(const file of tries){
      if(enumAborted) return;
      attempted++;
      try {
        const r = await fetch(file, {cache:'no-store'});
        if(!r.ok) { continue; }
        const obj = await r.json();
        if(metaList.some(m => m.file === file)) continue; // avoid dup
  const entry = normalizeMetaFromRaw(file, obj);
        metaList.push(entry);
        filtered = metaList.slice();
        setStatus(`Discovered ${metaList.length} file(s) ... (arbitrary)`);
        updateProgress(attempted / tries.length);
        render();
      } catch(e){ /* ignore */ }
    }
    showProgress(false);
    if(!metaList.length){
      setStatus('No portfolios found (heuristic scan empty).');
    } else {
      setStatus('');
    }
  }

  function showProgress(on){
    if(!scanProgress) return;
    scanProgress.style.display = on ? 'block' : 'none';
    if(on && scanBar) scanBar.style.width = '4%';
  }
  function updateProgress(f){ if(scanBar) scanBar.style.width = Math.min(100, Math.max(4, f*100)).toFixed(1)+'%'; }

  function normalizeMetaFromRaw(file, raw){
    const name = raw.name || raw.title || 'Untitled';
    const m = { file, name };
    const n = (name||'').toLowerCase();
    const f = (file||'').toLowerCase();
    m._name = n;
    m._terms = `${n} ${f}`.trim();
    return m;
  }

  // firstImage removed (no longer needed)

  if(searchBox){ searchBox.addEventListener('input', applyFilter); }
  if(scanToggle){
    scanToggle.addEventListener('change', ()=>{
      if(!scanToggle.checked){
        enumAborted = true;
        showProgress(false);
        setStatus('Auto scan disabled.');
      } else {
        enumAborted = false;
        if(!metaList.length){ scheduleEnumerationFallback(); }
      }
    });
  }
  loadIndex();
  // Note: Chrome "Intervention" message about lazy images is informational only; we intentionally use native lazy-loading.
})();
